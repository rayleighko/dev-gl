## 목차

* Google Search Guideline
* Shell
* Git
* IDE
* OOP
* Restful API
* Functional Programming
* TDD
* DDD

### Google Search Guideline

우리가 개발자로 일하는동안 하루도 빠짐없이 만나게 될 'Google Search'를 살펴보도록 할게요! 우선적으로 '검색'이라는 행위는 타자를 칠 수 있다면 누구나 할 수 있습니다. 하지만 검색을 '잘' 하기란 쉽지 않죠.

그래서 어떤 분들은 개발 실력을 '검색 기술'이라고도 이야기합니다. 그만큼 검색을 어떻게 하느냐에 따라서 결과의 질이 달라지기 때문이죠. :)

그래서 우리는 앞으로 개발 인생에서 두고두고 만나게 될 'Google Search'를 잘하는 방법에 대해 살펴보도록 하겠습니다.

#### 마음가짐

검색을 하는데 마음가짐이 왜 중요한지 궁금하신가요? 검색을 할 때 가장 중요한 마음가짐이 '끈기'와 '인내'이기 때문이에요. :) 검색을 하기 위해서는 원하는 결과가 나올 때까지 인내하고 끈기있게 검색해야 하죠.

더불어 우리는 '혼자' 개발하고 있기 때문에 주변에 물어볼 수도 없습니다. 반드시 스스로 자신이 겪는 문제를 해결해야 하죠.

그리고 끈기와 인내처럼 중요한 것이 "어떻게 해야 제대로 된 결과를 얻을 수 있을까?"에 대한 고민이 필요하다는 것입니다. 가령 '어떻게 동작하는지는 몰라도 서버에서 express라는 기술을 쓰는데, 클라이언트에 데이터를 동기적으로 전송하고 싶다'면 어떻게 하면 좋을까요?

```
"어떻게 동작하는지는 모르겠는데 express로 클라이언트에 데이터를 동기적으로 전송하는 방법이 있을까요?"
```

이렇게 검색하면 좋을까요? 그렇지 않다는 것을 어렴풋이 느끼시나요? 그렇다면 성공입니다! 우리는 이미 "어떻게 해야 제대로 된 결과를 얻을 수 있을까?"에 대한 고민을 하고 있는 거지요! 그럼 더 나아가서 생각해볼까요?

#### 문제 정의

문제를 만나면 먼저 해야할 것은 '문제 정의'입니다. 제대로 된 결과를 위해서는 제대로 된 문제가 필요하겠죠? 그렇지않고서는 우리가 원하지 않는 결과를 얻을 확률이 큽니다.

실제로 개발을 할 때도 마찬가지입니다. 제대로 문제를 정의하고 이를 해결해야 처음에 정의한 문제에 대한 답을 얻을 수 있기 때문입니다.

그렇다면 어떤 방식으로 문제를 정의하면 좋을까요? 우선 앞서 말한 주제를 바탕으로 생각해봅시다. 필요없는 내용은 과감히 지우세요!

```
우리가 모르는 것: express에서 클라이언트로의 동기적인 데이터 전송은 어떻게 하나요?
```

이제 문제가 정의되었습니다. 검색하는데 필요한 건 '키워드'이기 때문에 문제를 정의할 때 우리가 원하는 답의 키워드가 아닌 '어떻게 동작하는지 몰라요'를 제거했습니다. 그렇다면 다음에 필요한 건 뭘까요?

#### 번역

세계의 개발자들은 어떤 언어로 소통할까요? 한글? 일본어? 그렇습니다! 바로 영어로 소통합니다. 만약 C언어나 다른 프로그래밍 언어를 생각하셨다면 부끄러움은 제 몫입니다. 그만하세요.

우리가 앞서 정의한 문제를 영어로 번역하는 작업이 필요합니다. 하지만, 검색할 때마다 매번 구글 번역기를 돌릴 수는 없겠죠? 그러니 영어 실력도 검색 능력에 영향을 준다는 것을 명심하세요. 오늘부터 영어도 공부하는 겁니다. :)

```
how to using the express synchronous communication?
```

결론적으로 우리는 번역에 성공했습니다. 사실 이대로 검색해도 원하는 결과를 얻을 가능성이 있습니다. 하지만, 여기에는 한 가지 걸림돌이 있습니다. 바로 기술적인 부분에 대한 이해없이 작성되었다는 게 그 부분입니다.

이 다음에 소개될 내용은 조금 더 개발에 대한 기반 지식이 필요한 내용이기 때문에 외우기라도 하고 넘어가야 합니다. 왜냐면 우리는 앞으로 기반 지식에 대해서도 다룰 거기 때문이죠!

#### 기술적인 용어로 치환하기

이미 개발에 대한 경험이 있다면, 우리는 손쉽게 혹은 애초에 키워드를 고를 때 다음과 같이 기술적인 내용을 담을 수 있습니다.

```
how to using the synchronous request in express?
```

여기서 다소 생소한 단어가 등장했습니다. 'request'라는 녀석이 말이죠! 일반적으로 서버와 클라이언트의 통신에서 request는 이름 그대로 '요청'을 나타냅니다.

갑자기 무슨 요청을 하냐고 생각하실 수도 있지만, 클라이언트와 서버는 요청과 응답(response)로 통신을 하기 때문이라는 것만 알아주세요! 자세한 내용은 다른 자료를 보며 외워보도록 하자구요. :)

이제 우리는 '검색'에 대해 입문할 수 있게 되었습니다. 여기에 추가적으로 본인만의 노하우를 생각해볼 수도 있어요. 가령 문장형이 아닌 다음과 같이 단어로 검색한다거나,

```
express synchronous request
```

구글 검색 엔진의 다양한 키워드를 사용한다거나 말이죠!

```
how to using the synchronous request in "express" '2015-2019'?
```

더 자세한 내용은 구글에 'google search tips'를 검색해 [구글 검색 20가지 팁](https://www.lifehack.org/articles/technology/20-tips-use-google-search-efficiently.html)과 같은 자료를 읽어보는 거지만, 여기서는 이런 방법이 있구나만 알고 넘어가도록 합시다!

중요한 건 검색해서 원하는 정보를 얻는 것이지 화려한 기술을 사용하는 게 아니니까요! 그럼 다음 주제로 넘어갑시다! 안녕!

### Shell

다음은 '쉘'이라고 부르는 'Shell'에 대한 이야기입니다. Shell을 알기 위해서는 운영체제의 동작원리를 이해해야 합니다. 우리가 프로그래밍 언어로 코드를 작성했을 때 코드가 컴파일되거나 인터프리팅되는 것을 컴퓨터(HW)를 위한 '번역'이라고 생각해봅시다. 이렇게 컴퓨터를 위해 번역된 프로그래밍 언어는 컴퓨터에게 전달되어 특정 동작을 수행하게 되는 것이죠.

이런 맥락과 같이 쉘은 컴퓨터에게 명령어를 번역하기 위한 도구의 역할을 하게 됩니다. 프로그래밍 인어로 치면 에디터의 역할을 한다고 볼 수 있습니다. 가령 'Hello World를 출력해!'를 컴퓨터에게 컴파일해서 보내는 것과 같이 '이 파일을 저기로 복사해줘!'하고 컴퓨터에게 커널링해서 보내는 거라고 생각하시면 됩니다.

그래서 `사용자(프로그래밍 언어 작성) -> 에디터 -> 컴파일러`라는 구조처럼 `사용자(쉘 명령어 작성) -> 쉘 -> 커널`이라는 구조로 동작하는 것이죠. 아마 우리는 이미 쉘과 커널을 접해봤을 수도 있습니다. 가령 Mac에서는 'Terminal', PC(Windows)에서는 'Powershell'이라고 부르는 환경에서 말이죠.

더불어 간단한 쉘 명령을 알고 있으면 다른 자료에서 다룰 '자동화'를 쉽게 할 수 있기도 합니다. 당장은 필요하지 않을 수도 있지만, 만약 여러분이 터미널 환경에서 작업(Git-bash에서나 개발의 편의성을 위해)하게 될 수도 있기 때문에 아주 간단한 명령어를 알아두면 좋습니다.

또, 프로그래밍 에디터가 다양한 것처럼 쉘도 다양합니다. 그 중 대표적으로 사용되는 게 'bash'(배쉬 쉘)라는 쉘인데, 그래서 여기서는 이 bash에서 사용할 수 있는 간단한 명령어들을 살펴보도록 하겠습니다.

#### 현재 디렉터리 확인하기 - pwd

```
// 형식  

pwd
```
  
```
// 사용 예  

[user1@localhost ~]$ pwd
/home/user1
[user1@localhost ~]$
```
  
#### 디렉터리 이동하기 - cd  

```
// 형식  

cd {디렉터리 명}
```
  
```
// 사용 예  

[user1@localhost ~]$ cd /tmp
[user1@localhost tmp]$ pwd
/tmp
[user1@localhost tmp]$ cd
[user1@localhost ~]$ cd lib
[user1@localhost lib]$ cd ..
[user1@localhost ~]$
```
  
#### 디렉터리 내용 보기 - ls  

```
// 형식  

ls {옵션} {서브디렉터리 or 파일명}
```

```
// 옵션  

-a : 숨김 파일을 포함하여 모든 파일 목록을 출력한다.
-d : 지정한 디렉터리 자체의 정보를 출력한다.
-i : 첫 번째 행에 inode 번호를 출력한다.
-l : 파일의 상세 정보를 출력한다.
-A : .와 ..을 제외한 모든 파일 목록을 출력한다.
-F : 파일의 종류를 표시한다(*: 실행파일, /: 디렉터리, @: 심벌릭 링크).
-L : 심벌릭 링크 파일의 경우 원본 파일의 정보를 출력한다.
-R : 하위 디렉터리 목록까지 출력한다.
```
  
```
// 사용 예  

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
```
  
#### 디렉터리 만들기 - mkdir  

```
//형식  

mkdir [옵션] 디렉터리명
```
  
```
// 옵션  

-p : 하위 디렉터리를 계층적으로 생성할 때 중간 단계의 디렉터리가 없으면 자동으로 중간 단계 디렉터리를 생성하면서 전체 디렉터리를 구성한다.  
```
  
```
사용 예  

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
[user1@localhost ~]$ mkdir temp
[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악 temp
```
  
#### 디렉터리 삭제하기 - rm  

```
// 형식  

rm [옵션] 파일명
```
  
```
// 옵션  

-r : 디렉터리 형식도 포함하여 삭제
-f : 경고없이 강제(force) 삭제
```
  
```
// 사용 예  

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악 temp
[user1@localhost ~]$ rm -rf temp
[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
```

더불어 대부분 bash를 사용하는 운영체제 환경은 'UNIX(유닉스)'라고 부르는 운영체제를 기반으로 합니다. 그렇기 때문에 '유닉스'기반 운영체제라면 모든 곳에서 bash를 사용할 수도 있습니다! 가령 Mac의 터미널에서 사용하던 명령어를 익혀두면 Linux Ubuntu 운영체제를 사용해도 똑같이 동작하는 것입니다. :o

만약 쉘과 커널 혹은 운영체제에 대해 궁금하시다면 [Operating system [9th Ed]](http://www.yes24.com/24/goods/9253807?scode=032&OzSrank=1)나 [그림으로 배우는 구조와 원리 - 운영체제](http://www.yes24.com/Product/goods/29290543?scode=032&OzSrank=1) 등의 책을 읽어보시는 것도 도움이 될 거라고 생각해요(서점 직원 아님)! 그럼 안녕!

### Git

제가 예전에 Git을 공부하면서 가슴 속에 새긴 문장이 있습니다. "호랑이는 가죽을 남기고, 개발자는 Git History를 남긴다"는 말인데요. Git은 현재 개발을 하는 사람에게 있어 가장 중요한 도구로 자리잡게 되었습니다. 그렇다면 Git이란 무엇일까요?

우선 Git은 VCS(Version Control System)의 한 종류로 프로젝트의 버전을 관리하기 위한 도구입니다. Git말고도 SVN이나 Perforce과 같이 현재도 사용 중이고, 분야에 따라 선택할 수 있는 도구들이 다양합니다.

이제 Git이 무엇인지 알았으니 가장 기본적인 내용을 다뤄볼까요?

우선 Git을 공부할 때 필수적으로 살펴볼 바이블이 있습니다!. 바로 [Git(Pro) Book](https://git-scm.com/book/ko/v2)입니다! 하지만 바이블이라는 이름과 같이 읽으면 좋은 것을 알지만, 끝까지 완주하신 분들이 얼마 없다는 전설이 있습니다(성경을 완독하기는 힘드니까요). :o 

그래서 지금은 가장 기본적인 내용에 대해서만 살펴보도록 할게요. :)

#### 이것만은 꼭 알아두자!

우선 Git을 사용하기 위해서는 기본적으로 Git을 사용하면 어떤 일이 가능해지는 지 알아야합니다. 우선 Git은 프로젝트를 여행하는 하나의 타임머신이라고 생각해주세요. 그래서 우리는 시간 이동을 하면서 과거의 코드를 살펴보거나 수정할 수 있죠. 흔한 공상 과학 영화에서처럼 과거에 영향을 주면 미래에도 영향이 생기니 주의합시다!

더불어 Git이 프로젝트의 역사(History)를 관리할 때는 하나의 나무처럼 관리한다는 것을 명심하세요! 그래서 Git은 뿌리(Root)부터 나무가 성장하는 것을 '커밋'이라는 단위로 기록한답니다. :) 그래서 시간 여행을 할 때 과거로 돌아오기 위해서는 항상 '커밋'으로 마킹을 해놔야 합니다.

그리고 프로젝트의 역사가 하나의 나무라고 소개한 것처럼 '가지(Branch)'를 만들 수도 있습니다. 가령 4월 19일까지 하나의 가지를 만들고 그 가지에서는 댓글 기능을 구현하려고 한다면 '0419_comments'라는 가지를 만들어두고 여기서 작업을 하면 되겠죠? 그리고 하나의 가지에서 작업한 내용은 줄기(Master Branch)에 합칠(Merge) 수도 있습니다!

그래서 결과적으로 업무 흐름은 줄기(Master Branch)에서 하나의 가지(Branch)를 만들어 이 가지에 여러 커밋을 작성해 만든 다음에 다시 줄기로 합쳐주면 하나의 기능(feature)이 완성인 것입니다!

만약 여기까지 이해가 어려우시다면 앞서 설명드린 [Git(Pro) Book](https://git-scm.com/book/ko/v2)을 추천해요! 이 책을 다 읽으셨다면, 웬만한 개발자들보다 Git을 잘 다루시게 될 거에요. 장답합니다! :)

#### 그래도 기본적은 명령어는 알아야겠지?

적어도 이 4가지('status', 'add', 'commit', 'push') 명령어는 외워야 합니다. 사실 이것만 알면 혼자서 프로젝트 관리를 할 수 있기 때문이죠. 

그래서 이제부터 본격적으로 각 명령어에 대한 설명과 명령어의 기본적인 내용을 살펴보도록 합시다. 만약 여기서 이해가 안되시면 앞서 설명드린 책을 참고하시거나 구글에 검색하도록 합시다!

우선 'status' 명령어는 이름 그대로 상태를 나타냅니다. 여기서의 상태는 현재 내가 바라보고 있는 브랜치의 상태를 말합니다. 가령 커밋이 몇 개 작성되었는지, 파일의 변경은 있었는지 등을 나타내죠. 실제로 터미널 환경에서 가장 많이 쓰이는 명령어니까 기억해둡시다!

> // status: 현재 프로젝트의 상태 확인
>
> $ git status {...}

다음으로는 'add'입니다. 앞서 우리의 프로젝트는 하나의 커밋 단위로 기록된다고 말씀드렸는데, 'add'는 하나의 커밋에 작업(Work)을 추가할 때 사용합니다. 여기서는 하나의 '파일'이 아니라 '작업'이라고 말한 것을 명심하세요! 하나의 파일 안에서 여러 작업 단위를 분할 해 커밋할 수 있기 때문입니다! 이 내용은 나중에 살펴보도록 해요~

> // add: 커밋할 목록(Working Stage)에 추가(Staging)
>
> $ git add {options} {...}

앞서 자주 등장했던 'commit'입니다. History의 가장 작은 단위라고 할 수 있으며, 각각의 커밋은 설명(Description)이 포함되어 해당 커밋에서 작업한 내용을 기록할 수 있습니다.

> // commit: 커밋(History의 단위) 작성하기
>
> $ git commit {...}

지금까지 기록했던 커밋을 우리의 원격 저장소(remote repository)로 보내는(push) 작업을 말합니다! 원격 저장소에 보내는 것은 하나의 커밋이 작성될 때가 아닌 일정 기간을 두고 진행할 것을 추천합니다! 그래야 실수를 만회할 기회도 생기고 보다 신중하게 작업 단위를 구성할 수 있기 때문입니다. :)

> // push: 작업 시작부터 현재까지의 커밋을 Github에 밀어넣기
> 
> $ git push {...}

이제 Git에 대해 기본을 알게 되었네요! 축하드려요! 하지만 이론만 안다고 실제로 사용 가능한 것이 아니기 때문에 의식적인 수련이 필요합니다! 그래서 저는 gitHub을 사용할 것과 gitHub으로 프로젝트나 블로그를 관리할 것을 추천드려요!

이와 관련된 내용은 'gitHub 블로그'라던가 'gitHub 프로젝트'라는 키워드로 구글에 검색하시면 많은 자료들을 찾을 수 있습니다. 그럼 안녕!