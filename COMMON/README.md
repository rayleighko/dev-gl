# 목차

- Troubleshooting(문제 추적)
  - Google search(구글 검색)
  - Problem definition(문제 정의)
  - Translation(번역)
  - Replace in technical terms(기술적인 용어로 치환하기)
  - Problem solving with Datastructure, Algorithm(문제 해결)
- Design(설계)
  - Design Patterns(설계 패턴)
- Implementation(구현) - 작성중
- Configuration Management(형상 관리) with Git - 작성중
  - Git
  - Git's Workflow
- Efficient Development(효율적인 개발) - 작성중
  - Integrated Development Environment(IDE, 통합 개발 환경)
  - automation(자동화)
- Object-oriented Programming(객체 지향 프로그래밍) - 작성중
  - Modularization(모듈화)
  - Encapsulation(캡슐화)
- Function-oriented Programming
- Test-driven Development(테스트 주도 개발) - 작성중
  - 테스트 코드 작성 요령
- Domain-driven Development(도메인 주도 개발) - 작성중
- Application Programming Interface(API, 응용 프로그램 프로그래밍 인터페이스) - 작성중
  - Rest API
  - GraphQL API

## Troubleshooting

우리는 앞으로 다양한 문제들을 만나게 될 것이다. 하지만 이제 입문한 우리들은 문제를 어떻게 풀어야 하는지 아니, 그 전에 문제에 어떻게 접근해야 하는지조차 쉽게 가늠할 수 없을 것이다.

그래서 이번 장에서는 우리가 처한 상황에 대한 이야기를 시작으로 문제를 어떻게 정의해야 하고, 접근해야 하는지, 마지막에는 문제를 해결하는 방법을 고민해보려 한다.

처음부터 일이나 학습을 잘하는 사람은 없을 것이다. 이런 지능과 관련된 능력에 관한 자료 중에 (플린 효과](https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A6%B0_%ED%9A%A8%EA%B3%BC)라는 것이 있다.

이는 자식 세대가 부모 세대보다 상대적으로 지능지수(IQ)가 높은 경향을 보인다는 효과인데, 결과적으로 주니어가 시니어보다 성장에 한해서는 상대적으로 더 나은 여건 속에 있다는 것을 알 수 있을 것이다.

더불어 사회가 성장하며 시니어에 비해 '학습에 대한 기회'가 증가한 것도 사실이다. 그렇다면, 이런 시점에서 우리는 우리가 가진 자원을 최대한 활용해야 한다. 천공 카드에 구멍 뚫던 시절, 전산실에 박혀서 교수 혹은 선배에게 얻을 수 있는 정보가 전부가 아니라는 것이다.

그렇다면 본론으로 넘어가 보자. 우리는 앞으로 어떻게 문제를 해결할 것인가? 지금까지 이런 고민을 했던 적이 있는가? 가령 토이 프로젝트 혹은 학교 과제를 개발하다 버그를 만나게 되면 문제 해결 과정을 거치는가? 이에 대해서는 좀처럼 답하기 어렵다.

하지만, 우리는 분명 문제 해결 과정을 거치고 있다! 비록 무의식 중이지만, 우리는 다음과 같은 프로세스를 거치고 있는 것이다.

- 주제: 오늘 뭐먹지?
- 나는 오늘 뭘 먹을지 모른다.
- 먹을 것을 찾아야 한다(문제 정의)
- 주변에 어떤 음식이 있는지 검색을 하자!(문제 탐색 방법 선택)
- 검색 중(문제 탐색)
- 그래! 이걸 먹자!(문제 해결)

이 프로세스와 같이 우리는 문제를 정의하고, 이를 바탕으로 문제 탐색 과정을 거치고 결과적으로 문제를 해결하게 된다. 그렇다면 어떻게 하면 이 프로세스를 보다 효율적으로 발전시킬 수 있을까? 이제부터 그 방법을 살펴보도록 하자.

### Google Search

우선 '검색'이라는 행위는 타자를 칠 수 있다면 누구나 할 수 있다. 하지만 검색을 '잘' 하기란 쉽다. 그래서 어떤 이는 개발 실력을 '검색 기술'이라고 이야기한다. 그만큼 검색을 어떻게 하느냐에 따라서 결과의 질이 달라지기 때문인데, 근본적으로는 '문제 해결 능력'을 이야기하는 것이다. 그러니 이번 장에서는 '문제 해결'을 중심으로 '검색'에 대해 생각해보도록 하자.

여기서는 다양한 문제 탐색 방법 중 'Google Search'를 이용해 문제를 탐색하는 방법에 대해 살펴보도록 하자. 검색을 할 때 가장 중요한 마음가짐은 '끈기'와 '인내'이다. 그 이유는 검색을 통해 원하는 결과가 나올 때까지 그 과정을 반복해야 하는 것이다.

더불어 개인 프로젝트를 하게 되면 사수나 주변에 의견을 구할 수 없을 수도 있다. 그래서 반드시 스스로의 힘으로 자신이 겪고 있는 문제를 해결하는 법을 알아야 하는 것이다!

더불어 끈기와 인내만큼 "어떻게 해야 제대로 된 결과를 얻을 수 있을까?"에 대한 고민이 필요하다. 가령 지금 가지고 있는 문제가 "이게 어떻게 동작하는지는 몰라도 서버에서 express라는 기술을 쓰는데, 클라이언트에 데이터를 동기적으로 전송하고 싶다"라면 어떻게 검색하면 좋을까?

```
어떻게 동작하는지는 모르겠는데 express로 클라이언트에 데이터를 동기적으로 전송하는 방법이 있을까요?
```

우리는 이렇게 검색하면 좋지 않다는 것을 어렴풋이 느낄 수 있다. 그 이유는 이미 "어떻게 해야 제대로 된 결과를 얻을 수 있을까?"에 대한 고민을 하고 있기 때문이다. 그럼 더 나아가서 생각해보도록 하자.

### 문제 정의

문제를 만나면 먼저 해야할 것은 '문제 정의'이다. 제대로 된 결과를 위해서는 제대로 된 문제가 필요하다. 그렇지 않고서는 우리가 원하지 않은 결과를 얻을 확률이 크기 때문이다.

실제로 개발을 할 때도 마찬가지다. 제대로 문제를 정의하고 이를 해결해야만 처음에 정의한 문제에 대한 답을 얻을 수 있기 때문이다. 그렇다면 어떤 방식으로 문제를 정의하면 좋을까? 우선 앞서 말한 주제를 바탕으로 생각해보자. 검색어에서 필요없는 내용은 과감히 지우도록 하자!

```
express에서 클라이언트로의 동기적인 데이터 전송은 어떻게 하나요?
```

자, 이제 문제를 다듬어 다시 정의했다. 검색하는데 가장 중요한 건 '키워드'이기 때문에 문제를 정의할 때 우리가 원하는 키워드가 아닌(혹은 아니라고 생각하는) '어떻게 동작하는지 몰라요'를 제거했다. 그렇다면 다음에 필요한 건 뭘까?

### 번역

세계의 개발자들은 어떤 언어로 소통할까? 한글? 일본어? 그렇다! 바로 영어로 소통한다. 우리가 앞서 정의한 문제를 영어로 번역하는 작업이 필요하다. 그렇다고 영어를 공부하면서 개발을 공부할 필요는 없다. 물론 둘을 병행하면 좋지만, 근본적인 '문제 해결 방법'에 집중하도록 하자.

```
how to using the express synchronous communication?
```

이대로 검색해도 원하는 결과를 얻을 가능성이 있다. 하지만, 여기에는 한 가지 걸림돌이 있는데, 바로 기술적인 부분에 대한 이해없이 작성되었다는 것이다.

이 다음에 소개될 내용은 개발에 대한 기반 지식의 필요성에 대한 내용이기 때문에 반드시 명심하고 넘어가야 한다. 왜냐하면 우리는 앞으로 기반 지식을 위주로 문제를 다뤄야 하기 때문이다!

### 기술적인 용어로 치환하기

이 글의 독자가 이미 개발에 대한 경험이 있다면, 손쉽게 혹은 애초에 검색어를 완성할 때 다음과 같이 기술적인 내용을 담을 수 있다.

```
how to using the synchronous request(or message) in express?
```

여기서 다소 생소한 단어를 찾을 수 있다. 'request'라는 녀석이 그 녀석인데, 일반적으로 서버와 클라이언트의 통신에서 request(message)는 이름 그대로 '요청'을 나타낸다.

갑자기 무슨 요청을 하냐고 생각할 수도 있지만, 클라이언트와 서버는 요청(request)과 응답(response)으로 통신을 하기 때문이라는 것만 알아두고 넘어가도록 하자. 여기서는 클라이언트와 서버를 다루는 게 아닌 '문제 해결 능력'을 다루기 때문이다.

이제 우리는 '검색'에 대해 입문할 수 있게 되었다. 여기에 추가적으로 본인만의 노하우를 가미할 수도 있다. 가령 문장형이 아닌 다음과 같이 단어로 검색한다거나,

```
express synchronous request
```

구글 검색 엔진의 다양한 키워드('', "", () 등)를 사용해서 말이다!

```
how to using the synchronous request in "express" '2015-2019'?
```

더 자세한 내용은 구글에 'google search tips'를 검색해 [구글 검색 20가지 팁](https://www.lifehack.org/articles/technology/20-tips-use-google-search-efficiently.html)과 같은 자료를 읽어보는 거지만, 여기서는 이런 방법이 있구나만 알고 넘어가도록 하자! 앞서 말한 것처럼 중요한 건 검색해서 원하는 정보를 얻는 것이지 화려한 기술을 사용하는 게 아니기 때문이다.

### 문제 해결 with Datastructure, Algorithm

앞선 내용에서는 어떻게 하면 문제를 효율적으로 정의하고 탐색하는지를 살펴보았다. 그렇다면 마지막 주제인 '문제 해결'을 위해서는 어떤 고민이 필요할까? 그것은 바로 자료구조와 알고리즘에 대한 고민이다.

자료구조란 말 그대로 데이터의 구조를 정의할 때 주로 사용한다. 가령 데이터의 구조가 배열인지, 링크드 리스트인지, 큐인지, 스택인지 등을 이야기하며 다른 자료를 통해 살펴볼 것이다.

알고리즘은 문제의 로직을 파악하거나 문제를 해결하는 방식을 선정할 때 주로 사용한다. 가령 최단 거리를 탐색하기 위해서 Dijkstra algorithm을 사용하거나 트리를 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS)하는 것이 그 예이며 마찬가지로 다른 자료를 통해 살펴볼 것이다.

여기서는 문제를 효율적으로 해결하려면 주먹구구식의 방법보다 미리 선행된 방법을 이용하는 것이 낫다는 것을 이해하고 넘어가면 된다. 위에서 언급한 자료구조와 알고리즘을 선정하는 기준이 익숙해질 때 '문제 해결'을 효율적으로 한다고 말할 수 있다는 것을 알고 넘어가도록 하자.

## Design(설계)

설계는 요구사항 정의 혹은 문제 정의 이후 진행되는 작업을 말한다. 앞으로 어떤 구조로 구현할지를 결정하는 것이다. 더불어 반드시 설계는 유지보수성과 기능 확장의 용이성을 보장해야 한다. 그러기 위해서 설계를 한다고 하는 것이 적절하다. 그러니 앞으로 설계를 할 때 무조건적으로 유지보수성과 기능 확장의 용이성을 고려하도록 하자.

우선 설계를 진행할 때는 사업적 목표를 정의해야 한다. 왜 새로운 소프트웨어를 만들어야 하는지, 이루고자 하는 목표는 무엇인지를 명확하게 정의해야 한다. 그래야만 팀원의 커뮤니케이션에서 불필요한 과정을 배제할 수 있고 협업 구성원들이 비즈니스를 쉽게 이해하게 됨으로써 각자의 문제에 집중할 수 있다.

더불어 사용자가 서비스를 어떻게 사용하는지를 유즈케이스를 고민해야 한다. 여기서의 사용자는 서비스를 직접 사용하는 이들을 말하는데, 사용자가 우리의 서비스를 어떻게 사용할지 고민해야만 유의미한 설계를 진행할 수 있다. 왜냐하면 사용자 관점의 고민이 깊을수록 예외로 인한 에러나 오류 가능성이 줄어들고 서비스 구조가 명확해진다.

마찬가지로 좀 더 현실에 가깝게 유저 시나리오를 짜야 한다. 일반적인 관점에서 무턱대고 시나리오를 짜게 되면 개발자는 하나의 모듈에 여러 기능을 담을 수밖에 없다. 이는 결코 좋은 게 아니며 앞서 말한 시나리오가 얼마나 현실에 가깝냐에 따라 구현해야 할 기능이 명확해져서 모듈이 단순해진다.

또한, 유지보수를 고려해 설계해야 한다. 누가 어떻게 유지보수할 것인지를 고민해야 하며 운영될 때 주로 어떤 일들이 일어나는지를 생각해 설계해야 한다. 그래야만 서비스의 생명주기를 관리할 수 있고, 장기적으로 운영되는 소프트웨어를 만들 수 있다.

다음으로는 행복한 고민이지만, 꼭 해야 하는 '서비스가 잘되면'이라는 고민이다. 이는 유연성과 밀첩한 관계를 가진다. 우리 서비스의 확장 가능성이 어디까지인지, 서비스가 잘 될 경우 구조가 붕괴(서버 다운 등)되지는 않는지를 명확하게 알 필요가 있다. 더불어 유연성의 고민을 대용량 트래픽에 할지, 신규 서비스 로직에 할지를 선택하는 것도 설계의 목적에 해당한다.

이와 함께 사업을 지속, 확장하기 위해서는 고객을 분석해야 한다. 사용자 로그는 서비스의 방향을 결정짓는 가장 중요한 요인이라고 할 수 있기 때문에 고객 로그 데이터는 관리될 필요가 있고, 마찬가지로 관리를 하더라도 로그를 무의미하게 남기고 지워버리는 행위는 쓸모없기 때문에 로그는 가공될 필요가 있다.

오버 엔지니어링에도 유의해야 한다. 자동화를 하거나 도구를 사용하는 목적을 명확히 해야 한다. 1회용 프로젝트에 정신적 자원을 쏟아 붓는 일 따위는 사업의 속도를 늦출 뿐만 아니라 개발자 개인의 불만을 증대시킬 수 있다.

마지막으로 앞서 언급한 기술적인 요소(자동화된 프로세스, 서비스 구조)에서는 비즈니스의 핵심적인 가치(기업가치, 금전 등)가 만들어지지 않는다. 결정적인 부가가치를 만드는 것은 '사람'의 생각과 개입이 필수적이기 때문에 항상 누가, 언제, 왜, 어떻게, 어느 부분에 개입되는지를 명확히 해야 한다. 가령 UX 디자이너의 개입없이 프로젝트를 3개월동안 개발했는데, 추후에 수정 사항이 생겨 모든 로직을 변경해야 할 때가 발생할 수도 있다.

이처럼 설계를 할 때는 개발자들도 다양한 인과관계와 비즈니스의 근본을 이해해야 한다. 그저 PM이 시키는대로 개발하고 있으면, 그 누구도 원하지 않았던 기괴한 서비스가 탄생할 수도 있기 때문이다.

### Design Patterns(설계 패턴)

설계라는 말에서 알 수 있듯이 설계의 근본은 건축학에서 왔는데, 건축학의 크리스토퍼 알렉산더가 패턴화된 문제를 해결하기 위해 '설계 패턴'을 고안하였다. 이때의 설계 패턴은 건축학에서만 적용되는 것이 아닌 이후 컴퓨터 공학에도 영향을 끼쳐 소프트웨어를 재사용하기 용이하도록 고안한 설계 패턴이 등장했다.

설계 패턴은 GoF(Gang of Four)라 불리는 소프트웨어 디자인 패턴의 선두주자 4명이 참여한 [디자인 패턴](<https://ko.wikipedia.org/wiki/%EB%94%94%EC%9E%90%EC%9D%B8_%ED%8C%A8%ED%84%B4_(%EC%B1%85)>)이 출판되면서 소프트웨어 영역에서의 설계 패턴이 처음으로 책을 통해 이야기되었다(최초의 디자인 패턴은 C++과 스몰토크라는 언어를 통해 설명되었다).

하지만, 소프트웨어를 만드는 데 있어서 디자인 패턴이 항상 적용되어야 하는 것은 아니다. 앞선 것처럼 패턴은 재사용성이 용이하고, 대부분의 문제를 해결할 수 있다는 장점이 있지만, 적재적소에 적용되지 않으면 오히려 소프트웨어에 불필요한 복잡성을 부여하게 되어 유지보수에 용이하지 않다. 하물며 시니어가 현란한 기술과 패턴으로 소프트웨어를 만들어놓으면 개발에 익숙하지 않은 주니어는 접근하기 어렵기 때문에 디자인 패턴을 적용하기 전에 항상 유지보수성을 방해하지 않는지 고민해야 한다.

패턴의 종류는 크게 '생성', '구조', '행동' 3가지 패턴이 존재한다. 여기서는 자세히 언급하지 않고 목록만 나열할 것이며, 추후에 다른 자료에서 각각의 패턴을 살펴보도록 하자.

#### Creational Patterns(생성 패턴) 5가지

- 추상 팩토리 패턴: 동일한 주제의 다른 팩토리를 묶어 준다.
- 빌더 패턴: 생성(construction)과 표기(representation)를 분리해 복잡한 객체를 생성한다
- 팩토리 메서드 패턴: 생성할 객체의 클래스를 국한하지 않고 객체를 생성한다.
- 프로토타입 패턴: 기존 객체를 복제함으로써 객체를 생성한다.
- 싱글턴 패턴: 한 클래스에 한 객체만 존재하도록 제한한다.

#### Structural Patterns(구조 패턴) 7가지

- 어댑터 패턴: 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다.
- 브리지 패턴: 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있다.
- 합성 패턴: 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있다.
- 데코레이터 패턴: 기존 객체의 매서드에 새로운 행동을 추가하거나 오버라이드 할 수 있다.
- 파사드 패턴: 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스를 제공한다.
- 플라이웨이트 패턴: 다수의 유사한 객체를 생성·조작하는 비용을 절감할 수 있다.
- 프록시 패턴: 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공한다.

#### Behavioral Patterns(행동 패턴) 11가지

- 책임연쇄 패턴(Chain of responsibility): 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조
- 커맨드 패턴(Command Pattern: 위의 명령어를 각각 구현하는 것보다는 위 그림처럼 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행하는 것
- 해석자 패턴 (Interpreter Pattern): 문법 규칙을 클래스화한 구조를 갖는SQL 언어나 통신 프로토콜 같은 것을 개발할 때 사용
- 반복자 패턴 (Iterator Pattern): 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용할 수 있도록 해준다.
- 옵저버 패턴: 어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해주는 것
- 전략 패턴 (Strategy Pattern): 알고리즘 군을 정의하고 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 해준다.
- 템플릿 메서드 패턴 (Template method pattern): §상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴
- 방문자 패턴 (visitor Pattern): 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스로 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 것
- 중재자 패턴 (Mediator Pattern): 클래스간의 복잡한 상호작용을 캡슐화하여 한 클래스에 위임해서 처리 하는 디자인 패턴
- 상태 패턴 (State Pattern): 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용하는 디자인 패턴
- 기념품 패턴 (Memento Pattern): Ctrl + z 와 같은 undo 기능 개발할 때 유용한 디자인패턴. 클래스 설계 관점에서 객체의 정보를 저장

## implementation(구현)

구현을 효율적으로 하는 방법에 대해 살펴보도록 하자. 코드를 구현하는 것,

<!-- ### Shell

다음은 '쉘'이라고 부르는 'Shell'에 대한 이야기입니다. Shell을 알기 위해서는 우선 운영체제의 동작원리를 이해해야 합니다. 우리가 프로그래밍 언어로 코드를 작성했을 때 영어로 된 코드가 컴파일 혹은 인터프리팅되는 것을 컴퓨터(HW)를 위한 '번역'이라고 생각해봅시다. 그래서 이렇게 컴퓨터를 위해 번역된 프로그래밍 언어는 컴퓨터에게 전달되어 특정 동작을 수행하게 되는 것이죠.

이런 맥락과 같이 쉘은 컴퓨터에게 명령어를 번역하기 위한 도구의 역할을 하게 됩니다. 프로그래밍 인어로 치면 에디터의 역할을 한다고 볼 수 있습니다. 가령 'Hello World를 출력해!'를 컴퓨터에게 컴파일러를 통해서 보내는 것과 같이 '이 파일을 저기로 복사해줘!'하고 컴퓨터에게 '커널'을 통해서 보내는 거라고 생각하시면 됩니다.

그래서 `사용자(프로그래밍 언어 작성) -> 에디터 -> 컴파일러`라는 구조처럼 `사용자(쉘 명령어 작성) -> 쉘 -> 커널`이라는 구조로 동작하는 것이죠. 아마 우리는 이미 쉘과 커널을 접해봤을 수도 있습니다. 가령 Mac에서는 'Terminal', PC(Windows)에서는 'Powershell'이라고 부르는 환경에서 말이죠.

더불어 간단한 쉘 명령을 알고 있으면 다른 자료에서 다룰 '자동화'를 쉽게 할 수 있기도 합니다. 당장은 필요하지 않을 수도 있지만, 만약 여러분이 터미널 환경에서 작업(컨테이너 혹은 CUI에서의 작업이나 개발의 편의성을 위해)하게 될 수도 있기 때문에 아주 간단한 명령어를 알아두면 좋습니다.

또, 프로그래밍 에디터가 다양한 것처럼 쉘도 다양합니다. 그 중 대표적으로 사용되는 게 'bash'(배쉬 쉘)라는 쉘인데, 그래서 여기서는 이 bash에서 사용할 수 있는 간단한 명령어들을 살펴보도록 하겠습니다.

#### 현재 디렉터리 확인하기 - pwd

```
// 형식

pwd
```

```
// 사용 예

[user1@localhost ~]$ pwd
/home/user1
[user1@localhost ~]$
```

#### 디렉터리 이동하기 - cd

```
// 형식

cd {디렉터리 명}
```

```
// 사용 예

[user1@localhost ~]$ cd /tmp
[user1@localhost tmp]$ pwd
/tmp
[user1@localhost tmp]$ cd
[user1@localhost ~]$ cd lib
[user1@localhost lib]$ cd ..
[user1@localhost ~]$
```

#### 디렉터리 내용 보기 - ls

```
// 형식

ls {옵션} {서브디렉터리 or 파일명}
```

```
// 옵션

-a : 숨김 파일을 포함하여 모든 파일 목록을 출력한다.
-d : 지정한 디렉터리 자체의 정보를 출력한다.
-i : 첫 번째 행에 inode 번호를 출력한다.
-l : 파일의 상세 정보를 출력한다.
-A : .와 ..을 제외한 모든 파일 목록을 출력한다.
-F : 파일의 종류를 표시한다(*: 실행파일, /: 디렉터리, @: 심벌릭 링크).
-L : 심벌릭 링크 파일의 경우 원본 파일의 정보를 출력한다.
-R : 하위 디렉터리 목록까지 출력한다.
```

```
// 사용 예

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
```

#### 디렉터리 만들기 - mkdir

```
//형식

mkdir [옵션] 디렉터리명
```

```
// 옵션

-p : 하위 디렉터리를 계층적으로 생성할 때 중간 단계의 디렉터리가 없으면 자동으로 중간 단계 디렉터리를 생성하면서 전체 디렉터리를 구성한다.
```

```
사용 예

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
[user1@localhost ~]$ mkdir temp
[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악 temp
```

#### 디렉터리 삭제하기 - rm

```
// 형식

rm [옵션] 파일명
```

```
// 옵션

-r : 디렉터리 형식도 포함하여 삭제
-f : 경고없이 강제(force) 삭제
```

```
// 사용 예

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악 temp
[user1@localhost ~]$ rm -rf temp
[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
```

더불어 대부분 bash를 사용하는 운영체제 환경은 'UNIX(유닉스)'라고 부르는 운영체제를 기반으로 합니다. 그렇기 때문에 '유닉스'기반 운영체제라면 모든 곳에서 bash를 사용할 수도 있습니다! 가령 Mac의 터미널에서 사용하던 명령어를 익혀두면 Linux Ubuntu 운영체제를 사용해도 똑같이 동작하는 것입니다. :o

만약 쉘과 커널 혹은 운영체제에 대해 궁금하시다면 [Operating system [9th Ed]](http://www.yes24.com/24/goods/9253807?scode=032&OzSrank=1)나 [그림으로 배우는 구조와 원리 - 운영체제](http://www.yes24.com/Product/goods/29290543?scode=032&OzSrank=1) 등의 책을 읽어보시는 것도 도움이 될 거라고 생각해요(서점 직원 아님)! 그럼 안녕!

### Git

제가 예전에 Git을 공부하면서 가슴 속에 새긴 문장이 있습니다. "호랑이는 가죽을 남기고, 개발자는 Git History를 남긴다"는 말인데요. Git은 현재 개발을 하는 사람에게 있어 가장 중요한 도구로 자리잡게 되었습니다. 그렇다면 Git이란 무엇일까요?

우선 Git은 VCS(Version Control System)의 한 종류로 프로젝트의 버전을 관리하기 위한 도구입니다. Git말고도 SVN이나 Perforce과 같이 현재도 사용 중이고, 분야에 따라 선택할 수 있는 도구들이 다양합니다.

이제 Git이 무엇인지 알았으니 가장 기본적인 내용을 다뤄볼까요?

우선 Git을 공부할 때 필수적으로 살펴볼 바이블이 있습니다!. 바로 [Git(Pro) Book](https://git-scm.com/book/ko/v2)입니다! 하지만 바이블이라는 이름과 같이 읽으면 좋은 것을 알지만, 끝까지 완주하신 분들이 얼마 없다는 전설이 있습니다(성경을 완독하기는 힘드니까요). :o

그래서 지금은 가장 기본적인 내용에 대해서만 살펴보도록 할게요. :)

#### 이것만은 꼭 알아두자!

우선 Git을 사용하기 위해서는 기본적으로 Git을 사용하면 어떤 일이 가능해지는 지 알아야합니다. 우선 Git은 프로젝트를 여행하는 하나의 타임머신이라고 생각해주세요. 그래서 우리는 시간 이동을 하면서 과거의 코드를 살펴보거나 수정할 수 있죠. 흔한 공상 과학 영화에서처럼 과거에 영향을 주면 미래에도 영향이 생기니 주의합시다!

더불어 Git이 프로젝트의 역사(History)를 관리할 때는 하나의 나무처럼 관리한다는 것을 명심하세요! 그래서 Git은 뿌리(Root)부터 나무가 성장하는 것을 '커밋'이라는 단위로 기록한답니다. :) 그래서 시간 여행을 할 때 과거로 돌아오기 위해서는 항상 '커밋'으로 마킹을 해놔야 합니다.

그리고 프로젝트의 역사가 하나의 나무라고 소개한 것처럼 '가지(Branch)'를 만들 수도 있습니다. 가령 4월 19일까지 하나의 가지를 만들고 그 가지에서는 댓글 기능을 구현하려고 한다면 '0419_comments'라는 가지를 만들어두고 여기서 작업을 하면 되겠죠? 그리고 하나의 가지에서 작업한 내용은 줄기(Master Branch)에 합칠(Merge) 수도 있습니다!

그래서 결과적으로 업무 흐름은 줄기(Master Branch)에서 하나의 가지(Branch)를 만들어 이 가지에 여러 커밋을 작성해 만든 다음에 다시 줄기로 합쳐주면 하나의 기능(feature)이 완성인 것입니다!

만약 여기까지 이해가 어려우시다면 앞서 설명드린 [Git(Pro) Book](https://git-scm.com/book/ko/v2)을 추천해요! 이 책을 다 읽으셨다면, 웬만한 개발자들보다 Git을 잘 다루시게 될 거에요. 장답합니다! :)

#### 그래도 기본적은 명령어는 알아야겠지?

적어도 이 4가지('status', 'add', 'commit', 'push') 명령어는 외워야 합니다. 사실 이것만 알면 혼자서 프로젝트 관리를 할 수 있기 때문이죠.

그래서 이제부터 본격적으로 각 명령어에 대한 설명과 명령어의 기본적인 내용을 살펴보도록 합시다. 만약 여기서 이해가 안되시면 앞서 설명드린 책을 참고하시거나 구글에 검색하도록 합시다!

우선 'status' 명령어는 이름 그대로 상태를 나타냅니다. 여기서의 상태는 현재 내가 바라보고 있는 브랜치의 상태를 말합니다. 가령 커밋이 몇 개 작성되었는지, 파일의 변경은 있었는지 등을 나타내죠. 실제로 터미널 환경에서 가장 많이 쓰이는 명령어니까 기억해둡시다!

> // status: 현재 프로젝트의 상태 확인
>
> \$ git status {...}

다음으로는 'add'입니다. 앞서 우리의 프로젝트는 하나의 커밋 단위로 기록된다고 말씀드렸는데, 'add'는 하나의 커밋에 작업(Work)을 추가할 때 사용합니다. 여기서는 하나의 '파일'이 아니라 '작업'이라고 말한 것을 명심하세요! 하나의 파일 안에서 여러 작업 단위를 분할 해 커밋할 수 있기 때문입니다! 이 내용은 나중에 살펴보도록 해요~

> // add: 커밋할 목록(Working Stage)에 추가(Staging)
>
> \$ git add {options} {...}

앞서 자주 등장했던 'commit'입니다. History의 가장 작은 단위라고 할 수 있으며, 각각의 커밋은 설명(Description)이 포함되어 해당 커밋에서 작업한 내용을 기록할 수 있습니다.

> // commit: 커밋(History의 단위) 작성하기
>
> \$ git commit {...}

지금까지 기록했던 커밋을 우리의 원격 저장소(remote repository)로 보내는(push) 작업을 말합니다! 원격 저장소에 보내는 것은 하나의 커밋이 작성될 때가 아닌 일정 기간을 두고 진행할 것을 추천합니다! 그래야 실수를 만회할 기회도 생기고 보다 신중하게 작업 단위를 구성할 수 있기 때문입니다. :)

> // push: 작업 시작부터 현재까지의 커밋을 Github에 밀어넣기
>
> \$ git push {...}

이제 Git에 대해 기본을 알게 되었네요! 축하드려요! 하지만 이론만 안다고 실제로 사용 가능한 것이 아니기 때문에 의식적인 수련이 필요합니다! 그래서 저는 gitHub을 사용할 것과 gitHub으로 프로젝트나 블로그를 관리할 것을 추천드려요!

이와 관련된 내용은 'gitHub 블로그'라던가 'gitHub 프로젝트'라는 키워드로 구글에 검색하시면 많은 자료들을 찾을 수 있습니다. 그럼 안녕! -->
