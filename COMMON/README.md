# 목차

- Troubleshooting(문제 추적)
  - Google search(구글 검색)
  - Problem definition(문제 정의)
  - Translation(번역)
  - Replace in technical terms(기술적인 용어로 치환하기)
  - Problem solving with Datastructure, Algorithm(문제 해결)
- Implementation(구현) - 작성중
- Configuration Management(형상 관리) with Git - 작성중
  - Git
  - Git's Workflow
- Efficient Development(효율적인 개발) - 작성중
  - Integrated Development Environment(IDE, 통합 개발 환경)
  - automation(자동화)
- Object-oriented Programming(객체 지향 프로그래밍) - 작성중
  - Modularization(모듈화)
  - Encapsulation(캡슐화)
- Function-oriented Programming
- Test-driven Development(테스트 주도 개발) - 작성중
  - 테스트 코드 작성 요령
- Domain-driven Development(도메인 주도 개발) - 작성중
- Application Programming Interface(API, 응용 프로그램 프로그래밍 인터페이스) - 작성중
  - Rest API
  - GraphQL API

## Troubleshooting

우리는 앞으로 다양한 문제들을 만나게 될 것이다. 하지만 이제 입문한 우리들은 문제를 어떻게 풀어야 하는지 아니, 그 전에 문제에 어떻게 접근해야 하는지조차 쉽게 가늠할 수 없을 것이다.

그래서 이번 장에서는 우리가 처한 상황에 대한 이야기를 시작으로 문제를 어떻게 정의해야 하고, 접근해야 하는지, 마지막에는 문제를 해결하는 방법을 고민해보려 한다.

처음부터 일이나 학습을 잘하는 사람은 없을 것이다. 이런 지능과 관련된 능력에 관한 자료 중에 (플린 효과](https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A6%B0_%ED%9A%A8%EA%B3%BC)라는 것이 있다.

이는 자식 세대가 부모 세대보다 상대적으로 지능지수(IQ)가 높은 경향을 보인다는 효과인데, 결과적으로 주니어가 시니어보다 성장에 한해서는 상대적으로 더 나은 여건 속에 있다는 것을 알 수 있을 것이다.

더불어 사회가 성장하며 시니어에 비해 '학습에 대한 기회'가 증가한 것도 사실이다. 그렇다면, 이런 시점에서 우리는 우리가 가진 자원을 최대한 활용해야 한다. 천공 카드에 구멍 뚫던 시절, 전산실에 박혀서 교수 혹은 선배에게 얻을 수 있는 정보가 전부가 아니라는 것이다.

그렇다면 본론으로 넘어가 보자. 우리는 앞으로 어떻게 문제를 해결할 것인가? 지금까지 이런 고민을 했던 적이 있는가? 가령 토이 프로젝트 혹은 학교 과제를 개발하다 버그를 만나게 되면 문제 해결 과정을 거치는가? 이에 대해서는 좀처럼 답하기 어렵다.

하지만, 우리는 분명 문제 해결 과정을 거치고 있다! 비록 무의식 중이지만, 우리는 다음과 같은 프로세스를 거치고 있는 것이다.

- 주제: 오늘 뭐먹지?
- 나는 오늘 뭘 먹을지 모른다.
- 먹을 것을 찾아야 한다(문제 정의)
- 주변에 어떤 음식이 있는지 검색을 하자!(문제 탐색 방법 선택)
- 검색 중(문제 탐색)
- 그래! 이걸 먹자!(문제 해결)

이 프로세스와 같이 우리는 문제를 정의하고, 이를 바탕으로 문제 탐색 과정을 거치고 결과적으로 문제를 해결하게 된다. 그렇다면 어떻게 하면 이 프로세스를 보다 효율적으로 발전시킬 수 있을까? 이제부터 그 방법을 살펴보도록 하자.

### Google Search

우선 '검색'이라는 행위는 타자를 칠 수 있다면 누구나 할 수 있다. 하지만 검색을 '잘' 하기란 쉽다. 그래서 어떤 이는 개발 실력을 '검색 기술'이라고 이야기한다. 그만큼 검색을 어떻게 하느냐에 따라서 결과의 질이 달라지기 때문인데, 근본적으로는 '문제 해결 능력'을 이야기하는 것이다. 그러니 이번 장에서는 '문제 해결'을 중심으로 '검색'에 대해 생각해보도록 하자.

여기서는 다양한 문제 탐색 방법 중 'Google Search'를 이용해 문제를 탐색하는 방법에 대해 살펴보도록 하자. 검색을 할 때 가장 중요한 마음가짐은 '끈기'와 '인내'이다. 그 이유는 검색을 통해 원하는 결과가 나올 때까지 그 과정을 반복해야 하는 것이다.

더불어 개인 프로젝트를 하게 되면 사수나 주변에 의견을 구할 수 없을 수도 있다. 그래서 반드시 스스로의 힘으로 자신이 겪고 있는 문제를 해결하는 법을 알아야 하는 것이다!

더불어 끈기와 인내만큼 "어떻게 해야 제대로 된 결과를 얻을 수 있을까?"에 대한 고민이 필요하다. 가령 지금 가지고 있는 문제가 "이게 어떻게 동작하는지는 몰라도 서버에서 express라는 기술을 쓰는데, 클라이언트에 데이터를 동기적으로 전송하고 싶다"라면 어떻게 검색하면 좋을까?

```
어떻게 동작하는지는 모르겠는데 express로 클라이언트에 데이터를 동기적으로 전송하는 방법이 있을까요?
```

우리는 이렇게 검색하면 좋지 않다는 것을 어렴풋이 느낄 수 있다. 그 이유는 이미 "어떻게 해야 제대로 된 결과를 얻을 수 있을까?"에 대한 고민을 하고 있기 때문이다. 그럼 더 나아가서 생각해보도록 하자.

### 문제 정의

문제를 만나면 먼저 해야할 것은 '문제 정의'이다. 제대로 된 결과를 위해서는 제대로 된 문제가 필요하다. 그렇지 않고서는 우리가 원하지 않은 결과를 얻을 확률이 크기 때문이다.

실제로 개발을 할 때도 마찬가지다. 제대로 문제를 정의하고 이를 해결해야만 처음에 정의한 문제에 대한 답을 얻을 수 있기 때문이다. 그렇다면 어떤 방식으로 문제를 정의하면 좋을까? 우선 앞서 말한 주제를 바탕으로 생각해보자. 검색어에서 필요없는 내용은 과감히 지우도록 하자!

```
express에서 클라이언트로의 동기적인 데이터 전송은 어떻게 하나요?
```

자, 이제 문제를 다듬어 다시 정의했다. 검색하는데 가장 중요한 건 '키워드'이기 때문에 문제를 정의할 때 우리가 원하는 키워드가 아닌(혹은 아니라고 생각하는) '어떻게 동작하는지 몰라요'를 제거했다. 그렇다면 다음에 필요한 건 뭘까?

### 번역

세계의 개발자들은 어떤 언어로 소통할까? 한글? 일본어? 그렇다! 바로 영어로 소통한다. 우리가 앞서 정의한 문제를 영어로 번역하는 작업이 필요하다. 그렇다고 영어를 공부하면서 개발을 공부할 필요는 없다. 물론 둘을 병행하면 좋지만, 근본적인 '문제 해결 방법'에 집중하도록 하자.

```
how to using the express synchronous communication?
```

이대로 검색해도 원하는 결과를 얻을 가능성이 있다. 하지만, 여기에는 한 가지 걸림돌이 있는데, 바로 기술적인 부분에 대한 이해없이 작성되었다는 것이다.

이 다음에 소개될 내용은 개발에 대한 기반 지식의 필요성에 대한 내용이기 때문에 반드시 명심하고 넘어가야 한다. 왜냐하면 우리는 앞으로 기반 지식을 위주로 문제를 다뤄야 하기 때문이다!

### 기술적인 용어로 치환하기

이 글의 독자가 이미 개발에 대한 경험이 있다면, 손쉽게 혹은 애초에 검색어를 완성할 때 다음과 같이 기술적인 내용을 담을 수 있다.

```
how to using the synchronous request(or message) in express?
```

여기서 다소 생소한 단어를 찾을 수 있다. 'request'라는 녀석이 그 녀석인데, 일반적으로 서버와 클라이언트의 통신에서 request(message)는 이름 그대로 '요청'을 나타낸다.

갑자기 무슨 요청을 하냐고 생각할 수도 있지만, 클라이언트와 서버는 요청(request)과 응답(response)으로 통신을 하기 때문이라는 것만 알아두고 넘어가도록 하자. 여기서는 클라이언트와 서버를 다루는 게 아닌 '문제 해결 능력'을 다루기 때문이다.

이제 우리는 '검색'에 대해 입문할 수 있게 되었다. 여기에 추가적으로 본인만의 노하우를 가미할 수도 있다. 가령 문장형이 아닌 다음과 같이 단어로 검색한다거나,

```
express synchronous request
```

구글 검색 엔진의 다양한 키워드('', "", () 등)를 사용해서 말이다!

```
how to using the synchronous request in "express" '2015-2019'?
```

더 자세한 내용은 구글에 'google search tips'를 검색해 [구글 검색 20가지 팁](https://www.lifehack.org/articles/technology/20-tips-use-google-search-efficiently.html)과 같은 자료를 읽어보는 거지만, 여기서는 이런 방법이 있구나만 알고 넘어가도록 하자! 앞서 말한 것처럼 중요한 건 검색해서 원하는 정보를 얻는 것이지 화려한 기술을 사용하는 게 아니기 때문이다.

### 문제 해결 with Datastructure, Algorithm

앞선 내용에서는 어떻게 하면 문제를 효율적으로 정의하고 탐색하는지를 살펴보았다. 그렇다면 마지막 주제인 '문제 해결'을 위해서는 어떤 고민이 필요할까? 그것은 바로 자료구조와 알고리즘에 대한 고민이다.

자료구조란 말 그대로 데이터의 구조를 정의할 때 주로 사용한다. 가령 데이터의 구조가 배열인지, 링크드 리스트인지, 큐인지, 스택인지 등을 이야기하며 다른 자료를 통해 살펴볼 것이다.

알고리즘은 문제의 로직을 파악하거나 문제를 해결하는 방식을 선정할 때 주로 사용한다. 가령 최단 거리를 탐색하기 위해서 Dijkstra algorithm을 사용하거나 트리를 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS)하는 것이 그 예이며 마찬가지로 다른 자료를 통해 살펴볼 것이다.

여기서는 문제를 효율적으로 해결하려면 주먹구구식의 방법보다 미리 선행된 방법을 이용하는 것이 낫다는 것을 이해하고 넘어가면 된다. 위에서 언급한 자료구조와 알고리즘을 선정하는 기준이 익숙해질 때 '문제 해결'을 효율적으로 한다고 말할 수 있다는 것을 알고 넘어가도록 하자.

<!-- ### Shell

다음은 '쉘'이라고 부르는 'Shell'에 대한 이야기입니다. Shell을 알기 위해서는 우선 운영체제의 동작원리를 이해해야 합니다. 우리가 프로그래밍 언어로 코드를 작성했을 때 영어로 된 코드가 컴파일 혹은 인터프리팅되는 것을 컴퓨터(HW)를 위한 '번역'이라고 생각해봅시다. 그래서 이렇게 컴퓨터를 위해 번역된 프로그래밍 언어는 컴퓨터에게 전달되어 특정 동작을 수행하게 되는 것이죠.

이런 맥락과 같이 쉘은 컴퓨터에게 명령어를 번역하기 위한 도구의 역할을 하게 됩니다. 프로그래밍 인어로 치면 에디터의 역할을 한다고 볼 수 있습니다. 가령 'Hello World를 출력해!'를 컴퓨터에게 컴파일러를 통해서 보내는 것과 같이 '이 파일을 저기로 복사해줘!'하고 컴퓨터에게 '커널'을 통해서 보내는 거라고 생각하시면 됩니다.

그래서 `사용자(프로그래밍 언어 작성) -> 에디터 -> 컴파일러`라는 구조처럼 `사용자(쉘 명령어 작성) -> 쉘 -> 커널`이라는 구조로 동작하는 것이죠. 아마 우리는 이미 쉘과 커널을 접해봤을 수도 있습니다. 가령 Mac에서는 'Terminal', PC(Windows)에서는 'Powershell'이라고 부르는 환경에서 말이죠.

더불어 간단한 쉘 명령을 알고 있으면 다른 자료에서 다룰 '자동화'를 쉽게 할 수 있기도 합니다. 당장은 필요하지 않을 수도 있지만, 만약 여러분이 터미널 환경에서 작업(컨테이너 혹은 CUI에서의 작업이나 개발의 편의성을 위해)하게 될 수도 있기 때문에 아주 간단한 명령어를 알아두면 좋습니다.

또, 프로그래밍 에디터가 다양한 것처럼 쉘도 다양합니다. 그 중 대표적으로 사용되는 게 'bash'(배쉬 쉘)라는 쉘인데, 그래서 여기서는 이 bash에서 사용할 수 있는 간단한 명령어들을 살펴보도록 하겠습니다.

#### 현재 디렉터리 확인하기 - pwd

```
// 형식

pwd
```

```
// 사용 예

[user1@localhost ~]$ pwd
/home/user1
[user1@localhost ~]$
```

#### 디렉터리 이동하기 - cd

```
// 형식

cd {디렉터리 명}
```

```
// 사용 예

[user1@localhost ~]$ cd /tmp
[user1@localhost tmp]$ pwd
/tmp
[user1@localhost tmp]$ cd
[user1@localhost ~]$ cd lib
[user1@localhost lib]$ cd ..
[user1@localhost ~]$
```

#### 디렉터리 내용 보기 - ls

```
// 형식

ls {옵션} {서브디렉터리 or 파일명}
```

```
// 옵션

-a : 숨김 파일을 포함하여 모든 파일 목록을 출력한다.
-d : 지정한 디렉터리 자체의 정보를 출력한다.
-i : 첫 번째 행에 inode 번호를 출력한다.
-l : 파일의 상세 정보를 출력한다.
-A : .와 ..을 제외한 모든 파일 목록을 출력한다.
-F : 파일의 종류를 표시한다(*: 실행파일, /: 디렉터리, @: 심벌릭 링크).
-L : 심벌릭 링크 파일의 경우 원본 파일의 정보를 출력한다.
-R : 하위 디렉터리 목록까지 출력한다.
```

```
// 사용 예

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
```

#### 디렉터리 만들기 - mkdir

```
//형식

mkdir [옵션] 디렉터리명
```

```
// 옵션

-p : 하위 디렉터리를 계층적으로 생성할 때 중간 단계의 디렉터리가 없으면 자동으로 중간 단계 디렉터리를 생성하면서 전체 디렉터리를 구성한다.
```

```
사용 예

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
[user1@localhost ~]$ mkdir temp
[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악 temp
```

#### 디렉터리 삭제하기 - rm

```
// 형식

rm [옵션] 파일명
```

```
// 옵션

-r : 디렉터리 형식도 포함하여 삭제
-f : 경고없이 강제(force) 삭제
```

```
// 사용 예

[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악 temp
[user1@localhost ~]$ rm -rf temp
[user1@localhost ~]$ ls
공개 다운로드 문서 바탕화면 비디오 사진 서식 음악
```

더불어 대부분 bash를 사용하는 운영체제 환경은 'UNIX(유닉스)'라고 부르는 운영체제를 기반으로 합니다. 그렇기 때문에 '유닉스'기반 운영체제라면 모든 곳에서 bash를 사용할 수도 있습니다! 가령 Mac의 터미널에서 사용하던 명령어를 익혀두면 Linux Ubuntu 운영체제를 사용해도 똑같이 동작하는 것입니다. :o

만약 쉘과 커널 혹은 운영체제에 대해 궁금하시다면 [Operating system [9th Ed]](http://www.yes24.com/24/goods/9253807?scode=032&OzSrank=1)나 [그림으로 배우는 구조와 원리 - 운영체제](http://www.yes24.com/Product/goods/29290543?scode=032&OzSrank=1) 등의 책을 읽어보시는 것도 도움이 될 거라고 생각해요(서점 직원 아님)! 그럼 안녕!

### Git

제가 예전에 Git을 공부하면서 가슴 속에 새긴 문장이 있습니다. "호랑이는 가죽을 남기고, 개발자는 Git History를 남긴다"는 말인데요. Git은 현재 개발을 하는 사람에게 있어 가장 중요한 도구로 자리잡게 되었습니다. 그렇다면 Git이란 무엇일까요?

우선 Git은 VCS(Version Control System)의 한 종류로 프로젝트의 버전을 관리하기 위한 도구입니다. Git말고도 SVN이나 Perforce과 같이 현재도 사용 중이고, 분야에 따라 선택할 수 있는 도구들이 다양합니다.

이제 Git이 무엇인지 알았으니 가장 기본적인 내용을 다뤄볼까요?

우선 Git을 공부할 때 필수적으로 살펴볼 바이블이 있습니다!. 바로 [Git(Pro) Book](https://git-scm.com/book/ko/v2)입니다! 하지만 바이블이라는 이름과 같이 읽으면 좋은 것을 알지만, 끝까지 완주하신 분들이 얼마 없다는 전설이 있습니다(성경을 완독하기는 힘드니까요). :o

그래서 지금은 가장 기본적인 내용에 대해서만 살펴보도록 할게요. :)

#### 이것만은 꼭 알아두자!

우선 Git을 사용하기 위해서는 기본적으로 Git을 사용하면 어떤 일이 가능해지는 지 알아야합니다. 우선 Git은 프로젝트를 여행하는 하나의 타임머신이라고 생각해주세요. 그래서 우리는 시간 이동을 하면서 과거의 코드를 살펴보거나 수정할 수 있죠. 흔한 공상 과학 영화에서처럼 과거에 영향을 주면 미래에도 영향이 생기니 주의합시다!

더불어 Git이 프로젝트의 역사(History)를 관리할 때는 하나의 나무처럼 관리한다는 것을 명심하세요! 그래서 Git은 뿌리(Root)부터 나무가 성장하는 것을 '커밋'이라는 단위로 기록한답니다. :) 그래서 시간 여행을 할 때 과거로 돌아오기 위해서는 항상 '커밋'으로 마킹을 해놔야 합니다.

그리고 프로젝트의 역사가 하나의 나무라고 소개한 것처럼 '가지(Branch)'를 만들 수도 있습니다. 가령 4월 19일까지 하나의 가지를 만들고 그 가지에서는 댓글 기능을 구현하려고 한다면 '0419_comments'라는 가지를 만들어두고 여기서 작업을 하면 되겠죠? 그리고 하나의 가지에서 작업한 내용은 줄기(Master Branch)에 합칠(Merge) 수도 있습니다!

그래서 결과적으로 업무 흐름은 줄기(Master Branch)에서 하나의 가지(Branch)를 만들어 이 가지에 여러 커밋을 작성해 만든 다음에 다시 줄기로 합쳐주면 하나의 기능(feature)이 완성인 것입니다!

만약 여기까지 이해가 어려우시다면 앞서 설명드린 [Git(Pro) Book](https://git-scm.com/book/ko/v2)을 추천해요! 이 책을 다 읽으셨다면, 웬만한 개발자들보다 Git을 잘 다루시게 될 거에요. 장답합니다! :)

#### 그래도 기본적은 명령어는 알아야겠지?

적어도 이 4가지('status', 'add', 'commit', 'push') 명령어는 외워야 합니다. 사실 이것만 알면 혼자서 프로젝트 관리를 할 수 있기 때문이죠.

그래서 이제부터 본격적으로 각 명령어에 대한 설명과 명령어의 기본적인 내용을 살펴보도록 합시다. 만약 여기서 이해가 안되시면 앞서 설명드린 책을 참고하시거나 구글에 검색하도록 합시다!

우선 'status' 명령어는 이름 그대로 상태를 나타냅니다. 여기서의 상태는 현재 내가 바라보고 있는 브랜치의 상태를 말합니다. 가령 커밋이 몇 개 작성되었는지, 파일의 변경은 있었는지 등을 나타내죠. 실제로 터미널 환경에서 가장 많이 쓰이는 명령어니까 기억해둡시다!

> // status: 현재 프로젝트의 상태 확인
>
> \$ git status {...}

다음으로는 'add'입니다. 앞서 우리의 프로젝트는 하나의 커밋 단위로 기록된다고 말씀드렸는데, 'add'는 하나의 커밋에 작업(Work)을 추가할 때 사용합니다. 여기서는 하나의 '파일'이 아니라 '작업'이라고 말한 것을 명심하세요! 하나의 파일 안에서 여러 작업 단위를 분할 해 커밋할 수 있기 때문입니다! 이 내용은 나중에 살펴보도록 해요~

> // add: 커밋할 목록(Working Stage)에 추가(Staging)
>
> \$ git add {options} {...}

앞서 자주 등장했던 'commit'입니다. History의 가장 작은 단위라고 할 수 있으며, 각각의 커밋은 설명(Description)이 포함되어 해당 커밋에서 작업한 내용을 기록할 수 있습니다.

> // commit: 커밋(History의 단위) 작성하기
>
> \$ git commit {...}

지금까지 기록했던 커밋을 우리의 원격 저장소(remote repository)로 보내는(push) 작업을 말합니다! 원격 저장소에 보내는 것은 하나의 커밋이 작성될 때가 아닌 일정 기간을 두고 진행할 것을 추천합니다! 그래야 실수를 만회할 기회도 생기고 보다 신중하게 작업 단위를 구성할 수 있기 때문입니다. :)

> // push: 작업 시작부터 현재까지의 커밋을 Github에 밀어넣기
>
> \$ git push {...}

이제 Git에 대해 기본을 알게 되었네요! 축하드려요! 하지만 이론만 안다고 실제로 사용 가능한 것이 아니기 때문에 의식적인 수련이 필요합니다! 그래서 저는 gitHub을 사용할 것과 gitHub으로 프로젝트나 블로그를 관리할 것을 추천드려요!

이와 관련된 내용은 'gitHub 블로그'라던가 'gitHub 프로젝트'라는 키워드로 구글에 검색하시면 많은 자료들을 찾을 수 있습니다. 그럼 안녕! -->
